OneMQ
Huang jun wen (Jayven)
Last update: %%mtime(%c)

%!encoding: utf-8

= onemq-fs-queue =

Fs queue can be accessed by multiple producers and one consumer in one process.

Implement a shared memory multi-processes fs queue is harder. The main reason is:
 - Crash detection and recovery is harder to implement when multi-processes involved.


Fs queue use these kind of files: meta/src/index/data files.


== Meta file == 

Meta files contain meta information about one message queue.

=== Flags ===

|| flag name | desc | default |
| FLAG_SING_THD | Set if only allow one thread to access the queue. | unset |
| FLAG_MIRROR | Set if this queue is a mirror of another queue. (same uuid) | unset |
| FLAG_SAFER | Set if flush to disk on every enqueue. (default is every second or more) | unset |
| FLAG_SAVE_SRC | Set if need to save source and source seq. | unset |

=== File format ===

|| length | type | desc |
| **Static fields** |||
| 6 bytes | unsigned char[6] | "omq-fs" |
| 2 bytes | uint16_t | Version number. |
| 16 bytes | uuid_t | The uuid for the queue. |
| 4 bytes | uint32_t | Index entries number per index file. |
| 4 bytes | uint32_t | Data file size limit. |
| 8 bytes | uint64_t | Flags. |
| 216 bytes | unsigned char[216] | Unused. |
| **Dynamic fields** |||
| 4 bytes | uint32_t | Pid. |
| 4 bytes | uint32_t | Last flush time. |
| 252 bytes | unsigned char[252] | Unused. |
| **Consumer fields** |||
| 8 bytes | uint64_t | Head seq. (last seq read) |
| 248 bytes | unsigned char[248] | Unused. |
| **Producer fields** |||
| 8 bytes | uint64_t | Tail seq. (last seq written) | 
| 4 bytes | uint32_t | Message sources count. |
| 4 bytes | uint32_t | Last data file index. |
| 4 bytes | uint32_t | Last data file size. |
| 236 bytes | unsigned char[236] | Unused. |


=== XXX ===
- Fs-queue need a init to create mutexes for threads. (dlopen?)
- How to detect a process is crashed when writing data file? Since data files need to be purged. (time expire?)
- How producers tell consumer to consumer msg?


== Src file == 

=== File format ===

|| length | type | desc |
| 4 bytes | uint32_t | Src id. (start from 0) |
| 16 bytes | uuid_t | Message source. |
| 8 bytes | uint64_t | Last recv seq from this source. |
| 4 bytes | uint32_t | Last recv time from this source. |
| ... repeat ... |||


== Index file == 

=== File format ===

|| length | type | desc |
| 4 bytes | uint32_t | Data file id. (!=0xffffffff) |
| 4 bytes | uint32_t | Data file offset. |
| 4 bytes | uint32_t | Entry size. (include head) |
| 4 bytes | uint32_t | Enqueue time. |
| ... repeat ... |||

Otherwise:

|| length | type | desc |
| 4 bytes | uint32_t | 0xffffffff |
| 8 bytes | uint64_t | Next seq. |
| 4 bytes | uint32_t | Unused. |

== Data file == 

=== File format ===

|| length | type | desc |
| 4 bytes | uint32_t | Data size. (N) | 
| 4 bytes | uint32_t | Data write time. |
| 4 bytes | uint32_t | Src id. |
| 8 bytes | uint64_t | Src seq. |
| N bytes | unsigned char[N] | Msg data. |
| ... repeat ... |||
